import * as paillierBigint from 'paillier-bigint'
import * as bcu from 'bigint-crypto-utils'
import { createHash } from 'sha256-uint8array'
import { toBigEndian, toLittleEndian } from '../src/lib/mpz'
import { computeDigest, getBits, prover } from '../src/proof'
// import sha256 from 'crypto-js/sha256';
async function paillierTest() {
  let p = 148677972634832330983979593310074301486537017973460461278300587514468301043894574906886127642530475786889672304776052879927627556769456140664043088700743909632312483413393134504352834240399191134336344285483935856491230340093391784574980688823380828143810804684752914935441384845195613674104960646037368551517n;
  let q = 158741574437007245654463598139927898730476924736461654463975966787719309357536545869203069369466212089132653564188443272208127277664424448947476335413293018778018615899291704693105620242763173357203898195318179150836424196645745308205164116144020613415407736216097185962171301808761138424668335445923774195463n;

  // const privateKey = new paillierBigint.PrivateKey(p, q);
  // (asynchronous) creation of a random private, public key pair for the Paillier cryptosystem
  // const { publicKey, privateKey } = await paillierBigint.generateRandomKeys(3072)

  // Optionally, you can create your public/private keys from known parameters
  // const publicKey = new paillierBigint.PublicKey(n, g)
  // const privateKey = new paillierBigint.PrivateKey(lambda, mu, publicKey)
  // const cipher =242871945338220682599767917633470963447716596501976053297204875297106238528051634132276942742828466194166439257822965115470220742304824986178792274760672902731896327902400737843464431855571831916131204766278505443324890322190275805853076019680846388877180472165673841682291962905078723876602745616887953078163843318975151854660234567961952174848241433174538102790059144146124137214428449141586874152155880862956216404022966700115727231106995961939638230777036182743580724060765574634865870892096470759554154152121883453682195190398483005836997152016462293535091631611828568728770643390847438798328755354797518782223787977910280786437691445515899204172695691929510216308481691920590160323991632060537396154006705232322001413105915807699307077813076223186528108831394103392067278492571093684476892837040853996910420355731767770089747009119615353967872279974373676622828476701685494522120483893874262243714609430443545297879605874887019775240414349352454407133538802442909764675547413962989657223677878546262869318514370255337153226366653835092164907998840780994462534103931044701547520184140356322719526127966274868232486197861515293310381313787421008644472868841900783354425361325840588468311032587596397058529670058064713066005867778n;
  const cipher = 173195671142565067185955641295854596574712977699812542696820340537153560665425177829840670220669330733728739712708016318209790479745090846145931720070202924280931442372437364314991259546325211566591068835430538933426105876558050674527537921448134798447721077643117454054297998526817085636863516104342374083279128066868805084912163396462063420087269488935869849169852198561026882267425989698373989891556992045787487517856316371586100403313081099511414104617168047555860787264265593474658322945761781155573462045984886063657275500277330749629586553658579427732797961021046992338482617304943085752981542028974379631797387552921028031260068908218109766630905071031513498054911173676297847513293920764544921191847634496788056208700157857778715309652510262512909970066883185403076150028810757698946394793414014474424507452045354344793472582998436404441211684308475154994069049283551023157231649620955123907866717415431311082999506283426789459006429786511369742861652012310174477724397370482009694699231752571294938912060815076708151140810427097612239163171515000444268527848259309719690888369917111132713121803972770795061760752225103708166981574811854002189410984756387581435870836308910925995676212871184722286384028528872930276057533261n;
  // const m1 = 12345678901234567890n
  // const m2 = 5n
  // If using p,q of equivalent length, a simpler variant of the key
  // generation steps would be to set
  // g=n+1, lambda=(p-1)(q-1), mu=lambda.invertm(n)
  let n, g, lambda, mu
  n = p * q;
  g = n + 1n;
  lambda = (p - 1n) * (q - 1n)
  mu = bcu.modInv(lambda, n)
  const publicKey = new paillierBigint.PublicKey(n, g);
  // const privateKey = new paillierBigint.PrivateKey(lambda, mu, publicKey, p, q)
  // encryption/decryption
  const secret_x = 10000000n;
  const secret_r = 123123123n;
  const range = 300000000000000n;
  // const c2 = privateKey.decrypt(cipher);
  // console.log('c2: ', c2);
  // console.log('origin: ', privateKey.decrypt(c1)) // 12345678901234567890n

  const res = prover(publicKey, range, secret_x);

  console.log(JSON.stringify(res));
}
paillierTest() 
//checked
async function testcomputeDigest(){
  const hash=computeDigest([123123123123n,321312312312312312n,567876545678n])
  console.log(hash);
  //[
//    90,  67,  40,  75, 114, 187, 198,  77,
//    109, 102, 223,  47,  11,  93, 229,  30,
//    104, 200, 129, 161, 106,  96, 170,  69,
//    118, 209, 125,  54, 176, 253, 243, 182
//  ]
}

async function testBigIntSha256() {
  let sha256 = createHash('sha256')
  sha256.update(123123123n.toString(16));
  sha256.update(123123123n.toString(16));
  sha256.update(123123123n.toString(16));
  var hash = sha256.digest('hex');
  console.log(hash);
}
// testBigIntSha256();